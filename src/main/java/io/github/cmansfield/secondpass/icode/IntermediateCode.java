package io.github.cmansfield.secondpass.icode;

import org.apache.commons.lang3.StringUtils;
import io.github.cmansfield.compiler.Label;

import java.util.stream.Collectors;
import java.util.*;


public class IntermediateCode {
  private final Map<Label,Deque<String>> labelStackMap;
  private final List<Quad> endOfCodeSegICode;
  private List<Quad> staticInitializedICode;
  private final List<Quad> icode;
  private List<Quad> staticICode;
  private String nextLabel;
  
  public boolean isFieldDeclaration;        // NOSONAR
  
  public IntermediateCode() {
    labelStackMap = new EnumMap<>(Label.class);
    staticInitializedICode = new ArrayList<>();
    staticICode = new ArrayList<>();
    icode = new ArrayList<>();
    isFieldDeclaration = false;
    endOfCodeSegICode = new ArrayList<>();
  }

  public List<Quad> getICode() {
    return new ArrayList<>(icode);
  }

  public List<Quad> getEndOfCodeSegICode() {
    return endOfCodeSegICode;
  }

  /**
   * The Quad list endOfCodeSegICode is used to store any iCode that will need to be included 
   * at the very end of the code segment. For example, all iCode generated by template classes
   * will need to be included at the very end.
   * 
   * @param endOfCodeSegICode   A list of iCode to add to the end of the code segment
   */
  public void addAllEndOfCodeSegICode(List<Quad> endOfCodeSegICode) {
    this.endOfCodeSegICode.addAll(endOfCodeSegICode);
  }

  /**
   * This method will add all of the supplied iCode to the front of the list of the main iCode
   * 
   * @param frongICode    The new iCode to push to the front of the main body of iCode
   */
  public void addAllFrontICode(List<Quad> frongICode) {
    icode.addAll(0, frongICode);
  }
  
  public void clearEndOfCodeSegICode() {
    endOfCodeSegICode.clear();
  }
  
  /**
   * This method will 'pop' all of the static initialized field declaration iCode and return
   * the list of quads
   * 
   * @return    A list of quads
   */
  public List<Quad> popAllStaticInitializerICode() {
    List<Quad> staticInitICode = this.staticInitializedICode;
    this.staticInitializedICode = new ArrayList<>();
    return staticInitICode;
  }

  /**
   * This method will 'pop' all of the static field iCode and return the list of quads
   * 
   * @return    A list of quads
   */
  public List<Quad> popAllStaticICode() {
    List<Quad> staticQuads = staticICode;
    staticICode = new ArrayList<>();
    return staticQuads;
  }
  
  /**
   * Add a new quad to the list of quads
   * 
   * @param quad  New quad to add
   */
  public void add(Quad quad) {
    if(quad == null) {
      throw new IllegalArgumentException("Quads cannot be null");
    }
    if(nextLabel != null) {
      if(StringUtils.isNotBlank(quad.getLabel())) {
        throw new UnsupportedOperationException("There's a problem here that needs to be fixed");
      }
      
      quad.setLabel(nextLabel);
      nextLabel = null;
    }

    if(isFieldDeclaration) {
      staticInitializedICode.add(quad);
    }
    else {
      icode.add(quad);
    }
  }

  /**
   * This method will add a quad to the list of quads that will be added to the code segment
   * Any iCode that is produced by a static variable will be added to this list and then
   * initialized in the code segment before executing main.
   * 
   * public class MyClass {
   *   private static int number = 10;
   * }
   * 
   * Quad: 'MOV 10, number' would get added here
   * 
   * @param quad    The quad to be added to the static iCode list
   */
  public void addStatic(Quad quad) {
    if(quad == null) {
      throw new IllegalArgumentException("Quads cannot be null");
    }
    staticICode.add(quad);
  }
  
  public void clearNextLabel() {
    nextLabel = null;
  }
  
  /**
   * Set the label to be applied to the next quad added
   * 
   * @param label   The string value to apply
   */
  public void setNextLabel(String label) {
    if(nextLabel != null) {
      backPropagate(label);
    }
    nextLabel = label;
  }
  
  public String getNextLabel() {
    return nextLabel;
  }

  /**
   * If there is already a label on standby for the next quad and another label needs to 
   * take its place then we'll need to back propagate. Where all of the instances of the 
   * old label in any quad will be replaced with the new label. 
   * 
   * @param label   The new label to replace the old one
   */
  private void backPropagate(String label) {
    icode.forEach(quad -> {
      if(nextLabel.equals(quad.getOperand1())) {
        quad.setOperand1(label);
      }
      if(nextLabel.equals(quad.getOperand2())) {
        quad.setOperand2(label);
      }
      if(nextLabel.equals(quad.getOperand3())) {
        quad.setOperand3(label);
      }
    });
  }
  
  /**
   * Push a defined label ID onto the label stack, this is needed when dealing with 'if', 'else',
   * 'for', and 'while' statements. 
   * 
   * @param label   The type of label being stored
   * @param value   The label ID to store for later
   */
  public void pushLabel(Label label, String value) {
    if(label == null || StringUtils.isBlank(value)) {
      return;
    }
    labelStackMap.computeIfAbsent(label, lbl -> labelStackMap.put(lbl, new ArrayDeque<>()));
    
    labelStackMap.get(label).push(value);
  }

  /**
   * Pop a label ID off of the label stack.
   * 
   * @param label   The type of label being removed
   * @return        The label ID if found
   */
  public String popLabel(Label label) {
    if(label == null) {
      return null;
    }
    if(!labelStackMap.containsKey(label)) {
      return null;
    }
    if(labelStackMap.get(label) == null) {
      return null;
    }
    
    return labelStackMap.get(label).pop();
  }

  /**
   * This method will check to see if the latest quad matches the supplied opcode
   * 
   * @param opcode  Opcode to compare with
   * @return        Boolean true if they match
   */
  public boolean isLastOpcode(String opcode) {
    if(StringUtils.isBlank(opcode) || icode.isEmpty()) {
      return false;
    }
    return opcode.equals(icode.get(icode.size() - 1).getOpcode());
  }
  
  @Override
  public String toString() {
    return icode.stream()
            .map(Object::toString)
            .collect(Collectors.joining("\n"));
  }
}
